# 软件工程

- [软件工程](#软件工程)
  - [整体情况](#整体情况)
  - [软件工程概述](#软件工程概述)
  - [能力成熟度模型](#能力成熟度模型)
    - [能力成熟度模型CMM](#能力成熟度模型cmm)
    - [能力成熟度模型集成CMMI](#能力成熟度模型集成cmmi)
  - [软件过程/工程模型/信息系统生命周期典型模型](#软件过程工程模型信息系统生命周期典型模型)
    - [瀑布模型SDLC](#瀑布模型sdlc)
    - [原型化模型](#原型化模型)
    - [螺旋模型](#螺旋模型)
    - [V模型](#v模型)
    - [增量模型](#增量模型)
    - [其他模型](#其他模型)
    - [敏捷模型](#敏捷模型)
    - [统一过程模型RUP](#统一过程模型rup)
  - [逆向工程](#逆向工程)
  - [需求工程](#需求工程)
    - [软件需求](#软件需求)
    - [需求获取](#需求获取)
    - [需求分析](#需求分析)
    - [需求定义](#需求定义)
    - [需求验证](#需求验证)
    - [需求管理](#需求管理)
  - [系统设计](#系统设计)
  - [测试基础知识](#测试基础知识)
  - [系统运行与维护](#系统运行与维护)
  - [净室软件工程](#净室软件工程)
  - [基于构件的软件工程](#基于构件的软件工程)


## 整体情况
重点章节，选择题、案例、论文都会考到。选择题每年考12-15分左右。案例和论文会考到结构化、面向对象的分析与设计内容。论文也会考到软件开发模型、开发方法、基于构件的软件开发等内容。

## 软件工程概述
**软件开发生命周期**:
- **软件定义时期**:包括**可行性研究和详细需求分析过程,**任务是确定软件开发工程必须完成的总目标,具体可分成问题定义、可行性研究、需求分析等。
- **软件开发时期**:就是软件的**设计与实现**,可分成概要设计、详细设计、编码、测试等。
- **软件运行和维护**:就是把**软件产品移交给用户使用**。

**软件系统的文档**可以分为**用户文档和系统文档**两类,用户文档主要描述**系统功能和使用方法**,并不关系这些功能是怎样实现的;系统文档描述**系统设计、实现和测试等各方面的内容**。

**软件工程过程**是指为获得软件产品包括以下4个方面活动:
1. P(Plan)--**软件规格说明**。规定软件的功能及其运行时的限制。
2. D(Do)--**软件开发**。开发出满足规格说明的软件。
3. C(Check)--**软件确认**。确认开发的软件能够满足用户的需求。
4. A(Action)--**软件演进**。软件在运行过程中不断改进以满足客户所的需求。

**软件系统工具**通常可以按软件过程活动将软件工具分为:
- **软件开发工具**:需求分析工具、设计工具、编码与排错工具、测试工具等。
- **软件维护工具**:版本控制工具、文档分析工具、开发信息库工具、逆向工程工具、再工程工具。
- **软件管理和软件支持工具**:项目管理工具、配置管理工具、软件详评价工具、软件开发工具的评价和选择。

软件设计四个活动:**数据设计、架构(体系结构)设计、人机界面(接口)设计和过程设计**。

## 能力成熟度模型
衡量组织（公司）的能力成熟度。

### 能力成熟度模型CMM
一般来说适用于软件过程的能力评估。
![能力成熟度模型](./imgs/10-cmm.png)

### 能力成熟度模型集成CMMI
是**若干过程模型的综合和改进**,不仅仅软件,而是**支持多个工程学科和领域的、系统的、一致的过程改进框架**,能适应现代工程的特点和需要,能提高过程的质量和工作效率。

CMMI两种表示方法:
1. **阶段式模型**:类似于CMM,它**关注组织的成熟度**,五个成熟度模型如下:
![能力成熟度模型集成](./imgs/10-cmmi.png)
2. 连续式模型:关注每个过程域的能力,一个组织对不同的过程域可以达到不同的过程域能力等级。

## 软件过程/工程模型/信息系统生命周期典型模型
### 瀑布模型SDLC
> 适用于需求明确的情况。

瀑布模型(SDLC):瀑布模型是一个经典的软件生命周期模型,一般**将软件开发**分为:可行性分析(计划)、需求分析、软件设计(概要设计、详细设计)、编码(含单元测试)、测试、运行维护等几个阶段。
![瀑布模型](./imgs/10-pubu.png)

瀑布模型特点
1. 从**上一项开发活动接受该项活动的工作对象作为输入**。
2. 利用这一输入,**实施该项活动应完成的工作内容**。
3. 给出该项活动的**工作成果,作为输出**传给下一项开发活动。
4. 对**该项活动的实施工作成果进行评审**。若其工作成果得到确认,则继续进行下一项开发活动;否则返回前一项,甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件。

### 原型化模型
> 适用于需求不明确的情况。

原型化模型**第一步就是创建一个快速原型**,能够满足项目干系人与未来的用户可以与原型进行交互,再通过与相关干系人进行充分的讨论和分析,**最终弄清楚当前系统的需求**,进行了充分的了解之后,在原型的基础上开发出用户满意的产品。

原型法认为在很难一下子全面准确地提出用户需求的情况下,原型应当具备的特点如下：
1. **实际可行**
2. 具有**最终系统的基本特征**
3. **构造方便、快速,造价低**。原型法的特点在于原型法**对用户的需求是动态响应、逐步纳入的**。

### 螺旋模型
> 结合瀑布模型和原型模型。

螺旋模型是一个**演化软件过程模型**,将**原型实现的迭代特征与线性顺序(瀑布)模型中控制的和系统化的方面结合起**来。在螺旋模型中,**软件开发是一系列的增量发布**。
![螺旋模型](./imgs/10-luoxuan.png)

开发过程具有**周期性重复的螺旋线状**。四个象限分别标志每个周期所划分的四阶段:**制订计划、风险分析、实施工程和客户评估**。螺旋模型**强调了风险分析**,特别**适用于庞大而复杂的、高风险的系统**。

### V模型
> 测试阶段对应词：单编、集详、系概、验需。

**V模型**从整体上看起来,就是一个V字型的结构,由左右两边组成。左边的下画线分别代表了需求分析、概要设计、详细设计、编码。右边的上画线代表了单元测试、集成测试、系统测试与验收测试。V模型的特点如下:
1. **单元测试**的主要目的是针对**编码过程中**可能存在的各种错误;
2. **集成测试**的主要目的是针对**详细设计中**可能存在的问题;
3. **系统测试**主要针**对概要设计**,检查系统作为一个整体是否有效地得到运行;
4. **验收测试**通常由业务专家或者用户进行,以确认产品能真正符合用户业务上的需要。
5. V模型**用于需求明确和需求变更不频繁**的情形。

![V模型](./imgs/10-v-model.png)

### 增量模型
**首先开发核心模块功能**,而后与用户确认,之后再开发没核心模块的功能,即每次开发一部分功能,并与用户需求确认,最终完成项目开发，**优先级最高的服务最先交付**。

特点:但由于并不是从系统整体角度规划各个模块,**因此不利于模块划分**。难点在于**如何将客户需求划分为多个增量**。与原型不用的是**增量模型的每一次增量版本都可作为独立可操作的作品**,而原型的构造一般是为了演示。
![增量模型](./imgs/10-zengliang-model.png)

### 其他模型
喷泉模型:是一种**以用户需求为动力,以对象作为驱动的模型**,适合于**面向对象的开发方法**。使开发过程具有迭代性和无间隙性。

基于构件的开发模型CBSD:利用**预先包装的构件来构造应用系统**。构件可以是组织内部开发的构件,也可以是商品化成品软件构件。
- 特点是**增强了复用性**,在系统开发过程中,会构建一个构件库,供其他系统复
用,因此可以提高可靠性,节省时间和成本。

形式化方法模型:建立在**严格数学基础**上的一种软件开发方法,主要活动是
生成计算机软件形式化的数学规格说明。

### 敏捷模型
开发宣言:**个体和交互胜过过程和工具、可以工作的软件生过面面俱到的文档、客户合作胜过合同谈判、响应变化胜过遵循计划**。

![敏捷模型](./imgs/10-minjie.png)

敏捷方法区别于其他方法的两个特点:
1. 是"**适应性**"而非"预设性"。
2. 是"**面向人的**"而非"面向过程的"。

敏捷方法的核心思想:
1. 敏捷方法是**适应型**,而非可预测型。拥抱变化,适应变化。
2. 敏捷方法是**以人为本**,而非以过程为本。发挥人的特性。
3. **迭代增量式**的开发过程。以原型开发思想为基础,采用迭代增量式开发,发行版本小型化。

主要敏捷方法:
1. 极限编程(XP)。基础和价值观是**交流、朴素、反馈和勇气**,即任何一个软件项目都可以从4个方面入手进行改善:**加强交流;从简单做起;寻求反馈;勇于实事求是**。
   - XP是一种**近螺旋式**的开发方法,它**将复杂的开发过程分解为一个个相对比较简单的小周期**:通过积极的交流、反馈以及其他一系列的方法,开发人员和客户可以非常清楚老开发进度、变化、待解决的问题和潜在的困难等,并根据实际情况及时地调整开发过程。
   - XP提倡**测试先行**,为了将以后出现bug的几率降到最低。
2. 水晶系列方法。与XP方法一样,都有**以人为中心**的理念,但在实践上有所不同。其目的是发展一种提倡"机动性的"方法,包含具有共性的核心元素,**每个都含有独特的角色、过程模式、工作产品和实践**。
3. 并列争球法(Scrum)。是一种迭代的增量化过程,把**每段时间(如30天)一次的迭代称为"冲刺"(Sprint)**,并**按需求的优先级别**来实现产品,多个自组织和自治的人小组并行地递增实现产品。
4. 特性驱动开发方法(FDD)。是一个**迭代**的开发模型。认为有效的软你件开发需要3个要素:**人、过程和技术**。有5个核心过程:**开发整体对象模型、构造特征列表、计划特征开发、特征设计和特征构建**。

### 统一过程模型RUP
RUP描述了**如何有效地利用商业的、可靠的方法开发和部署软件**,是一种重量级过程。RUP类似个在线的指导者,它可以**为所有方面和层次的程序开发提供指导方针、模版以及事例支持**。

RUP软件开发生命周期是一个**二维的软件开发模型**,RUP中有**9个核心工作流**,如下:
1. **业务建模**:理解待开发系统所在的机构及其商业运作,确保所有参与与人员对待开发系统所在的机构有共同的认识,评估待开发系统对所在机构的影响。
2. **需求**:定义系统功能及用户界面,使客户知道系统的功能,使开发,人员理解系统的需求,为项目预算及计划提供基础。
3. **分析与设计**:把需求分析的结果转化为分析与设计模型。
4. **实现**:把设计模型转换为实现结果,对开发的代码做单元测试,将不同实现人员开发的模块集成为可执行系统。
5. **测试**:检查各子系统之间的交互、集成,验证所有需求是否均被皮正确实现,对发现的软件质量上的缺陷进行归档,对软件质量提出改进建议。
6. **部署**:打包、分发、安装软件,升级旧系统;培训用户及销售人员,并提供技术支持。
7. **配置与变更管理**:跟踪并维护系统开发过程中产生的所有制品的完整性和一致性。
8. **项目管理**:为软件开发项目提供计划、人员分配、执行、监控等方面的指导,为风险管理提供框架。
9. **环境**:为软件开发机构提供软件开发环境,即提供过程管理和二工具的支持。

RUP把软件开发生命周期划分为**多个循环**,每个循环生成产品的一个新的的版本,**每个循环依次由4个连续的阶段组成**,每个阶段完成确定的任务。这4个阶段如下：
- **初始阶段**:定义最终产品视图和业务模型,并**确定系统范围**。
- **细化阶段**:设计及确定**系统的体系结构**,制订工作计划及资源要求。
- **构造阶段**:**构造产品并继续演进需求**、体系结构、计划直至产品提交
- **移交阶段**:把产品**提交给用户使用**。

RUP中定义了如下一些**核心概念**,理解这些概念对于理解RUP很有帮助。
- 角色:**Who的问题**。角色描述某个人或一个小组的行为与职责。RUP预先定义了很多角色,如体系结构师、设计人员、实现人员、测试员和配置管理人员等,并对每一个角色的工作和职责都做了详尽的说明。
- 活动:**How的问题**。活动是一个有明确目的的独立工作单元。
- 制品:**What的问题**。制品是活动生成、创建或修改的一段信息。
- 工作流:**When的问题**。工作流描述了一个有意义的连续的活动序存列,每个工作流产生一些有价值的产品,并显示了角色之间的关系。

RUP的**特点**:
1. **用例驱动**:需求分析、设计、实现和测试等活动都是用例驱动的。
2. **以体系结构为中心**:包括系统的总体组织和全局控制、通信协议等。是一个多维的结构,会采用多个视图来描述。在典型的4+1视图模型中:
   - **分析人员和测试人员**关心的是系统的行为,会侧重于**用例视图**;
   - **最终用户**关心的是系统的功能,会侧重于**逻辑视图**;
   - **程序员**关心的是系统的配置、装配等问题,会侧重于**实现视图**;
   - **系统集成人员**关心的是系统的性能、可伸缩性、吞吐率等问题,会侧重于**进程视图**;
   - **系统工程师**关心的是系统的发布、安装、拓扑结构等问题,会侧重于**部署视图**。
![4+1视图模型](./imgs/10-4+1-view.png)
3. **迭代与增量**。把整个项目开发分为**多个迭代过程**。在每次选代中,只考虑系统的一部分需求,进行分析、设计、实现、测试和部署等过程;每次迭代是在己完成部部分的基础上进行的,每次增加一些新的功能实现,以此进行下去,直至最后项目的完成。

## 逆向工程
软件复用是**将已有软件的各种有关知识用于建立新的软件**,**以缩减软件开发和维护的花费**。软件复用是提高软件生产力和质量的一种重要技术。早期的软件复用主要是**代码级复用**,被复用的知识专指程序,后来扩大到包括**领域知识、开发经验、设计决定、体系结构、需求、设计、代码和文档等一切有关方面**。

逆向工程:软件的逆向工程是**分析程序,力图在比源代码更高抽象层次上建立程序的表示过程,逆向工程是设计的恢复过程**。逆向工程的四个级别:
- **实现级**:包括程序的抽象语法树、符号表、过程的设计表示。
- **结构级**:包括反映程序分量之间相互依赖关系的信息,例如调用图、经吉构图、程序和数据结构。
- **功能级**:包括反映程序段功能及程序段之间关系的信息,例如数据和控制流模型。
- **领域级**:包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息,例如E-R模型。

其中,**领域级抽象级别最高,完备性最低,实现级抽象级别最低,完备性最高**。

与逆向工程相关的概念有**重构、设计恢复、再工程和正向工程**：
1. 重构是指在**同一抽象级别上转换系统描述形式**。
2. 设计恢复是指借助工具**从已有程序中抽象出有关数据设计**、总体结构设计和过程设计等方面的信息。
3. 再工程是指**在逆向工程所获得信息的基础上,修改或重构已有的系统,产生系统的一个新版本**。再工程是对**现有系统的重新开发过程**,包括**逆向工程、新需求的考虑过程和正向工程**三个步骤。它不仅能从已存在的程序中重新获得设计信息,而且还能使用这些信息来重构现有系统,以改进它的综合质质量。在利用再工程重构现有系统的同时,一般会增加新的需求,包括增加新的功能和改善系统的性能。
4. 正向工程是指不仅从现有系统中恢复设计信息,而且**使用该信息去改变或重构现有系统**,以改善其整体质量。

## 需求工程
### 软件需求
**软件需求**:是指**用户对系统在功能、行为、性能、设计约束等方面的期望**。是指用户解决问题或达到目标所需的条件或能力,是系统可我系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力力,以及反映这些条件或能力的文档说明。

分为**需求开发**和**需求管理**两大过程,如下所示:
![软件需求](./imgs/10-xuqiu.png)

需求的分类：
- **业务需求**:反映**企业或客户对系统高层次的目标要求**,通常来自项目投资人、客户、市场营销部门或产品策划部门。通过业务需求可以确确定项目视图和范围。
- **用户需求**:描述的是**用户的具体目标,或用户要求系统必须能完成的任务。即描述了用户能使用系统来做什么**。通常采取用户访谈和问卷调查等方式,对用户使用的场景进行整理,从而建立用户需求。
- **系统需求**:从**系统的角度来说明软件的需求**,包括功能需求、非功能需求和设计约束等。
  - 1)功能需求:也称为行为需求,规定了**开发人员必须在系统中实现的软件功能**,用户利用这些功能来完成任务,满足业务需要。
  - 2)非功能需求:指**系统必须具备的属性或品质**,又可以细分为软件质量属性(如可维护性、可靠性、效率等)和其他非功能需求。
  - 3)设计约束:也称为限制条件或补充规约,通常是**对系统的一些约束说明**,例如必须采用国有自主知识产权的数据库系统,必须运行在UNIX操作系统之下等。

### 需求获取
**需求获取**:是一个确定和理解不同的项目干系人的需求和约束的过程。

常见的需求获取法包括:
1. 用户访谈:1对1-3,有代表性的用户。其形式包括结构化和非洁构化两种。
2. 问卷调查:用户多,无法一一访谈。
3. 采样:从种群中系统地选出有代表性的样本集的过程。样本数量=0.25(可信度因子/错误率)^2
4. 情节串联板:一系列图片,通过这些图片来讲故事。
5. **联合需求计划(JRP):**通过联合各个关键用户代表、系统分析师、开发团队代表一起,通过有组织的会议来讨论需求。
6. 需求记录技术:任务卡片、场景说明、用户故事、Volere白卡。

### 需求分析
需求分析:一个好的需求应该具有**无二义性、完整性**、一致性、可测试性、确定性、可跟踪性、正确性、必要性等特性,因此,需要分析人员**把杂乱无章的用户要求和期望转化为用户需求**,这就是需求分析的工作。

需求分析的任务：
1. 绘制系统上下文范围关系图
2. 创建用户界面原型
3. 分析需求的可行性
4. 确定需求的优先级
5. 为需求建立模型
6. 创建数据字典
7. 使用**QFD(质量功能部署)**

**结构化的需求分析**

结构化特点:**自顶向下,逐步分解,面向数据**。

三大模型:**功能模型(数据流图)、行为模型(状态转换图)、数据模型(E-R图)以及数据字典**。
![结构化的需求分析](./imgs/10-xuqiu-1.png)

- **数据流图DFD**

基本图形元素:外部实体、加工、数据存储、数据流。
![数据流图DFD](./imgs/10-data-flow.png)

具体实例：
1. 数据流:由一组固定成分的数据组成,表示数据的流向。在DFD中,**数据流的流向必须经过加工**。
2. 加工:描述了输入数据流到输出数据流之间的变换,数据流图中常见的三种错误如图所示:
- 加工3.1.2有输入但是没有输出,称之为"黑洞"。
- 加工3.1.3有输出但没有输入。称之为"奇迹"。
- 加工3.1.1中输入不足以产生输出,我们称之为"灰洞"。
3. 数据存储:用来存储数据。
4. 外部实体(外部主体):是指存在于**软件系统之外**的人员或组织,它指出系统所需数据的发源地(源)和系统所产生的数据的归宿地(宿)。
![数据流图DFD实例](./imgs/10-data-flow-1.png)

**分层数据流图**

![分层数据流图](./imgs/10-data-flow-2.png)
![分层数据流图](./imgs/10-data-flow-3.png)

- **数据字典DD**
数据字典DD
数据流图描述了系统的分解,但没有对图中各成分进行说明。**数据字典就是为数据流图中的每个数据流、文件、加工,以及组成数据流或文件的数据项做出说明。**

数据字典有以下4类条目:**数据流、数据项、数据存储和基本加工**。
![数据字典](./imgs/10-dd.png)
加工逻辑也称为"小说明"。常用的加工逻辑描述方法有**结构化语言、判定表和判定树**3种。

### 需求定义
**需求定义(软件需求规格说明书SRS)**:是需求开发活动的产物,编制该文档的目的是使项目干系人与开发团队对系统的初始规定有一个共同的理解,使之成为**整个开发工作的基础**。SRS是软件开发过程中最重要的文档之一,对于任何规模和性质的软件项目都不应该缺少。

需求定义方法
1. 严格定义也称为预先定义,需求的严格定义建立**在以下的基本假设**之上**所有需求都能够被预先定义**。开发人员与用户之间能够准确而青晰地交流。采用图形(或文字)可以充分体现最终系统。
2. 原型方法,**迭代的循环型开发方式**,需要注意的问题:并非所有的需求都能在系统开发前被准确地说明。项目干系人之间通常都存在交流上的困难,原型提供**了克服该困难的一个手段**。特点:需要实际的、可供用户参与的系统模型。有合适的系统开发环境。反复是完全需要和值得提倡的,需需求一旦确定,就应遵从严格的方法。

### 需求验证
需求验证:也称为需求确认,目的是**与用户一起确认需求无误**,对需求规格说明书SAS进行评审和测试,包括两个步骤:
- 需求评审:正式评审和非正式评审。
- 需求测试:设计概念测试用例。

需求验证通过后,要请用户签字确认,作为验收标准之一,此时,这个需求规格说明书就是需求基线,不可以再随意更新,如果需要更改必须走需求变更流程。

### 需求管理
定义需求基线:通过了评审的需求说明书就是需求基线,下次如果需要变更
需求,就需要按照流程来一步步进行。需求的流程及状态如下图所示:
![需求管理](./imgs/10-xuqiu-man.png)

**需求变更和风险**

主要关心需求变更过程中的需求风险管理,带有风险的做法有:**无足够用户参与、忽略了用户分类、用户需求的不断增加、模棱两可的需求、不必要的特性、过于精简的SRS、不准确的估算**。

变更产生的原因:**外部环境的变化、需求和设计做的不够完整、新技术的出现、公司机构重组造成业务流程的变化**。

**变更控制委员会CCB**:也称为配置控制委员会,其任务时对建议的配置项变更做出评价、审批,以及监督已经批准变更的实施。
![需求变更](./imgs/10-xuqiu-xiugai.png)

双向跟踪,两个层次,如下图所示:
![需求跟踪](./imgs/10-xuqiu-genzong.png)

正向跟踪表示**用户原始需求是否都实现了**,反向跟踪**表示软件实现的是否都是用户要求的**,不多不少,可以用原始需求和用例表格(需求)跟踪矩阵来表示:

若原始需求和用例有对应,则在对应栏打对号,若某行都没有对号,表明原始需求未实现,正向跟踪发现问题;若某列都没有对号,表明有多余功能用例软件实现了多余功能,反向跟踪发现问题。

## 系统设计
## 测试基础知识
## 系统运行与维护
## 净室软件工程
## 基于构件的软件工程